{"ast":null,"code":"/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// VARIABLES //\nvar RE = /%(?:([1-9]\\d*)\\$)?([0 +\\-#]*)(\\*|\\d+)?(?:(\\.)(\\*|\\d+)?)?[hlL]?([%A-Za-z])/g;\n\n// FUNCTIONS //\n\n/**\n* Parses a delimiter.\n*\n* @private\n* @param {Array} match - regular expression match\n* @returns {Object} delimiter token object\n*/\nfunction parse(match) {\n  var token = {\n    'mapping': match[1] ? parseInt(match[1], 10) : void 0,\n    'flags': match[2],\n    'width': match[3],\n    'precision': match[5],\n    'specifier': match[6]\n  };\n  if (match[4] === '.' && match[5] === void 0) {\n    token.precision = '1';\n  }\n  return token;\n}\n\n// MAIN //\n\n/**\n* Tokenizes a string into an array of string parts and format identifier objects.\n*\n* @param {string} str - input string\n* @returns {Array} tokens\n*\n* @example\n* var tokens = formatTokenize( 'Hello %s!' );\n* // returns [ 'Hello ', {...}, '!' ]\n*/\nfunction formatTokenize(str) {\n  var content;\n  var tokens;\n  var match;\n  var prev;\n  tokens = [];\n  prev = 0;\n  match = RE.exec(str);\n  while (match) {\n    content = str.slice(prev, RE.lastIndex - match[0].length);\n    if (content.length) {\n      tokens.push(content);\n    }\n    tokens.push(parse(match));\n    prev = RE.lastIndex;\n    match = RE.exec(str);\n  }\n  content = str.slice(prev);\n  if (content.length) {\n    tokens.push(content);\n  }\n  return tokens;\n}\n\n// EXPORTS //\n\nmodule.exports = formatTokenize;","map":{"version":3,"names":["RE","parse","match","token","parseInt","precision","formatTokenize","str","content","tokens","prev","exec","slice","lastIndex","length","push","module","exports"],"sources":["D:/INTERNSHIP-PROJECT-WORK/stat/node_modules/@stdlib/string-base-format-tokenize/lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// VARIABLES //\n\nvar RE = /%(?:([1-9]\\d*)\\$)?([0 +\\-#]*)(\\*|\\d+)?(?:(\\.)(\\*|\\d+)?)?[hlL]?([%A-Za-z])/g;\n\n\n// FUNCTIONS //\n\n/**\n* Parses a delimiter.\n*\n* @private\n* @param {Array} match - regular expression match\n* @returns {Object} delimiter token object\n*/\nfunction parse( match ) {\n\tvar token = {\n\t\t'mapping': ( match[ 1 ] ) ? parseInt( match[ 1 ], 10 ) : void 0,\n\t\t'flags': match[ 2 ],\n\t\t'width': match[ 3 ],\n\t\t'precision': match[ 5 ],\n\t\t'specifier': match[ 6 ]\n\t};\n\tif ( match[ 4 ] === '.' && match[ 5 ] === void 0 ) {\n\t\ttoken.precision = '1';\n\t}\n\treturn token;\n}\n\n\n// MAIN //\n\n/**\n* Tokenizes a string into an array of string parts and format identifier objects.\n*\n* @param {string} str - input string\n* @returns {Array} tokens\n*\n* @example\n* var tokens = formatTokenize( 'Hello %s!' );\n* // returns [ 'Hello ', {...}, '!' ]\n*/\nfunction formatTokenize( str ) {\n\tvar content;\n\tvar tokens;\n\tvar match;\n\tvar prev;\n\n\ttokens = [];\n\tprev = 0;\n\tmatch = RE.exec( str );\n\twhile ( match ) {\n\t\tcontent = str.slice( prev, RE.lastIndex - match[ 0 ].length );\n\t\tif ( content.length ) {\n\t\t\ttokens.push( content );\n\t\t}\n\t\ttokens.push( parse( match ) );\n\t\tprev = RE.lastIndex;\n\t\tmatch = RE.exec( str );\n\t}\n\tcontent = str.slice( prev );\n\tif ( content.length ) {\n\t\ttokens.push( content );\n\t}\n\treturn tokens;\n}\n\n\n// EXPORTS //\n\nmodule.exports = formatTokenize;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AAEA,IAAIA,EAAE,GAAG,4EAA4E;;AAGrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAAEC,KAAK,EAAG;EACvB,IAAIC,KAAK,GAAG;IACX,SAAS,EAAID,KAAK,CAAE,CAAC,CAAE,GAAKE,QAAQ,CAAEF,KAAK,CAAE,CAAC,CAAE,EAAE,EAAG,CAAC,GAAG,KAAK,CAAC;IAC/D,OAAO,EAAEA,KAAK,CAAE,CAAC,CAAE;IACnB,OAAO,EAAEA,KAAK,CAAE,CAAC,CAAE;IACnB,WAAW,EAAEA,KAAK,CAAE,CAAC,CAAE;IACvB,WAAW,EAAEA,KAAK,CAAE,CAAC;EACtB,CAAC;EACD,IAAKA,KAAK,CAAE,CAAC,CAAE,KAAK,GAAG,IAAIA,KAAK,CAAE,CAAC,CAAE,KAAK,KAAK,CAAC,EAAG;IAClDC,KAAK,CAACE,SAAS,GAAG,GAAG;EACtB;EACA,OAAOF,KAAK;AACb;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,cAAcA,CAAEC,GAAG,EAAG;EAC9B,IAAIC,OAAO;EACX,IAAIC,MAAM;EACV,IAAIP,KAAK;EACT,IAAIQ,IAAI;EAERD,MAAM,GAAG,EAAE;EACXC,IAAI,GAAG,CAAC;EACRR,KAAK,GAAGF,EAAE,CAACW,IAAI,CAAEJ,GAAI,CAAC;EACtB,OAAQL,KAAK,EAAG;IACfM,OAAO,GAAGD,GAAG,CAACK,KAAK,CAAEF,IAAI,EAAEV,EAAE,CAACa,SAAS,GAAGX,KAAK,CAAE,CAAC,CAAE,CAACY,MAAO,CAAC;IAC7D,IAAKN,OAAO,CAACM,MAAM,EAAG;MACrBL,MAAM,CAACM,IAAI,CAAEP,OAAQ,CAAC;IACvB;IACAC,MAAM,CAACM,IAAI,CAAEd,KAAK,CAAEC,KAAM,CAAE,CAAC;IAC7BQ,IAAI,GAAGV,EAAE,CAACa,SAAS;IACnBX,KAAK,GAAGF,EAAE,CAACW,IAAI,CAAEJ,GAAI,CAAC;EACvB;EACAC,OAAO,GAAGD,GAAG,CAACK,KAAK,CAAEF,IAAK,CAAC;EAC3B,IAAKF,OAAO,CAACM,MAAM,EAAG;IACrBL,MAAM,CAACM,IAAI,CAAEP,OAAQ,CAAC;EACvB;EACA,OAAOC,MAAM;AACd;;AAGA;;AAEAO,MAAM,CAACC,OAAO,GAAGX,cAAc","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}