{"ast":null,"code":"/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar formatInteger = require('./format_integer.js');\nvar isString = require('./is_string.js');\nvar formatDouble = require('./format_double.js');\nvar spacePad = require('./space_pad.js');\nvar zeroPad = require('./zero_pad.js');\n\n// VARIABLES //\n\nvar fromCharCode = String.fromCharCode;\nvar isArray = Array.isArray; // NOTE: We use the global `Array.isArray` function here instead of `@stdlib/assert/is-array` to avoid circular dependencies.\n\n// FUNCTIONS //\n\n/**\n* Returns a boolean indicating whether a value is `NaN`.\n*\n* @private\n* @param {*} value - input value\n* @returns {boolean} boolean indicating whether a value is `NaN`\n*\n* @example\n* var bool = isnan( NaN );\n* // returns true\n*\n* @example\n* var bool = isnan( 4 );\n* // returns false\n*/\nfunction isnan(value) {\n  // explicitly define a function here instead of `@stdlib/math/base/assert/is-nan` in order to avoid circular dependencies\n  return value !== value;\n}\n\n/**\n* Initializes token object with properties of supplied format identifier object or default values if not present.\n*\n* @private\n* @param {Object} token - format identifier object\n* @returns {Object} token object\n*/\nfunction initialize(token) {\n  var out = {};\n  out.specifier = token.specifier;\n  out.precision = token.precision === void 0 ? 1 : token.precision;\n  out.width = token.width;\n  out.flags = token.flags || '';\n  out.mapping = token.mapping;\n  return out;\n}\n\n// MAIN //\n\n/**\n* Generates string from a token array by interpolating values.\n*\n* @param {Array} tokens - string parts and format identifier objects\n* @param {Array} ...args - variable values\n* @throws {TypeError} first argument must be an array\n* @throws {Error} invalid flags\n* @returns {string} formatted string\n*\n* @example\n* var tokens = [ 'beep ', { 'specifier': 's' } ];\n* var out = formatInterpolate( tokens, 'boop' );\n* // returns 'beep boop'\n*/\nfunction formatInterpolate(tokens) {\n  var hasPeriod;\n  var flags;\n  var token;\n  var flag;\n  var num;\n  var out;\n  var pos;\n  var i;\n  var j;\n  if (!isArray(tokens)) {\n    throw new TypeError('invalid argument. First argument must be an array. Value: `' + tokens + '`.');\n  }\n  out = '';\n  pos = 1;\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n    if (isString(token)) {\n      out += token;\n    } else {\n      hasPeriod = token.precision !== void 0;\n      token = initialize(token);\n      if (!token.specifier) {\n        throw new TypeError('invalid argument. Token is missing `specifier` property. Index: `' + i + '`. Value: `' + token + '`.');\n      }\n      if (token.mapping) {\n        pos = token.mapping;\n      }\n      flags = token.flags;\n      for (j = 0; j < flags.length; j++) {\n        flag = flags.charAt(j);\n        switch (flag) {\n          case ' ':\n            token.sign = ' ';\n            break;\n          case '+':\n            token.sign = '+';\n            break;\n          case '-':\n            token.padRight = true;\n            token.padZeros = false;\n            break;\n          case '0':\n            token.padZeros = flags.indexOf('-') < 0; // NOTE: We use built-in `Array.prototype.indexOf` here instead of `@stdlib/assert/contains` in order to avoid circular dependencies.\n            break;\n          case '#':\n            token.alternate = true;\n            break;\n          default:\n            throw new Error('invalid flag: ' + flag);\n        }\n      }\n      if (token.width === '*') {\n        token.width = parseInt(arguments[pos], 10);\n        pos += 1;\n        if (isnan(token.width)) {\n          throw new TypeError('the argument for * width at position ' + pos + ' is not a number. Value: `' + token.width + '`.');\n        }\n        if (token.width < 0) {\n          token.padRight = true;\n          token.width = -token.width;\n        }\n      }\n      if (hasPeriod) {\n        if (token.precision === '*') {\n          token.precision = parseInt(arguments[pos], 10);\n          pos += 1;\n          if (isnan(token.precision)) {\n            throw new TypeError('the argument for * precision at position ' + pos + ' is not a number. Value: `' + token.precision + '`.');\n          }\n          if (token.precision < 0) {\n            token.precision = 1;\n            hasPeriod = false;\n          }\n        }\n      }\n      token.arg = arguments[pos];\n      switch (token.specifier) {\n        case 'b':\n        case 'o':\n        case 'x':\n        case 'X':\n        case 'd':\n        case 'i':\n        case 'u':\n          // Case: %b (binary), %o (octal), %x, %X (hexadecimal), %d, %i (decimal), %u (unsigned decimal)\n          if (hasPeriod) {\n            token.padZeros = false;\n          }\n          token.arg = formatInteger(token);\n          break;\n        case 's':\n          // Case: %s (string)\n          token.maxWidth = hasPeriod ? token.precision : -1;\n          token.arg = String(token.arg);\n          break;\n        case 'c':\n          // Case: %c (character)\n          if (!isnan(token.arg)) {\n            num = parseInt(token.arg, 10);\n            if (num < 0 || num > 127) {\n              throw new Error('invalid character code. Value: ' + token.arg);\n            }\n            token.arg = isnan(num) ? String(token.arg) : fromCharCode(num); // eslint-disable-line max-len\n          }\n          break;\n        case 'e':\n        case 'E':\n        case 'f':\n        case 'F':\n        case 'g':\n        case 'G':\n          // Case: %e, %E (scientific notation), %f, %F (decimal floating point), %g, %G (uses the shorter of %e/E or %f/F)\n          if (!hasPeriod) {\n            token.precision = 6;\n          }\n          token.arg = formatDouble(token);\n          break;\n        default:\n          throw new Error('invalid specifier: ' + token.specifier);\n      }\n      // Fit argument into field width...\n      if (token.maxWidth >= 0 && token.arg.length > token.maxWidth) {\n        token.arg = token.arg.substring(0, token.maxWidth);\n      }\n      if (token.padZeros) {\n        token.arg = zeroPad(token.arg, token.width || token.precision, token.padRight); // eslint-disable-line max-len\n      } else if (token.width) {\n        token.arg = spacePad(token.arg, token.width, token.padRight);\n      }\n      out += token.arg || '';\n      pos += 1;\n    }\n  }\n  return out;\n}\n\n// EXPORTS //\n\nmodule.exports = formatInterpolate;","map":{"version":3,"names":["formatInteger","require","isString","formatDouble","spacePad","zeroPad","fromCharCode","String","isArray","Array","isnan","value","initialize","token","out","specifier","precision","width","flags","mapping","formatInterpolate","tokens","hasPeriod","flag","num","pos","i","j","TypeError","length","charAt","sign","padRight","padZeros","indexOf","alternate","Error","parseInt","arguments","arg","maxWidth","substring","module","exports"],"sources":["D:/INTERNSHIP-PROJECT-WORK/stat/node_modules/@stdlib/string-base-format-interpolate/lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar formatInteger = require( './format_integer.js' );\nvar isString = require( './is_string.js' );\nvar formatDouble = require( './format_double.js' );\nvar spacePad = require( './space_pad.js' );\nvar zeroPad = require( './zero_pad.js' );\n\n\n// VARIABLES //\n\nvar fromCharCode = String.fromCharCode;\nvar isArray = Array.isArray; // NOTE: We use the global `Array.isArray` function here instead of `@stdlib/assert/is-array` to avoid circular dependencies.\n\n\n// FUNCTIONS //\n\n/**\n* Returns a boolean indicating whether a value is `NaN`.\n*\n* @private\n* @param {*} value - input value\n* @returns {boolean} boolean indicating whether a value is `NaN`\n*\n* @example\n* var bool = isnan( NaN );\n* // returns true\n*\n* @example\n* var bool = isnan( 4 );\n* // returns false\n*/\nfunction isnan( value ) { // explicitly define a function here instead of `@stdlib/math/base/assert/is-nan` in order to avoid circular dependencies\n\treturn ( value !== value );\n}\n\n/**\n* Initializes token object with properties of supplied format identifier object or default values if not present.\n*\n* @private\n* @param {Object} token - format identifier object\n* @returns {Object} token object\n*/\nfunction initialize( token ) {\n\tvar out = {};\n\tout.specifier = token.specifier;\n\tout.precision = ( token.precision === void 0 ) ? 1 : token.precision;\n\tout.width = token.width;\n\tout.flags = token.flags || '';\n\tout.mapping = token.mapping;\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Generates string from a token array by interpolating values.\n*\n* @param {Array} tokens - string parts and format identifier objects\n* @param {Array} ...args - variable values\n* @throws {TypeError} first argument must be an array\n* @throws {Error} invalid flags\n* @returns {string} formatted string\n*\n* @example\n* var tokens = [ 'beep ', { 'specifier': 's' } ];\n* var out = formatInterpolate( tokens, 'boop' );\n* // returns 'beep boop'\n*/\nfunction formatInterpolate( tokens ) {\n\tvar hasPeriod;\n\tvar flags;\n\tvar token;\n\tvar flag;\n\tvar num;\n\tvar out;\n\tvar pos;\n\tvar i;\n\tvar j;\n\n\tif ( !isArray( tokens ) ) {\n\t\tthrow new TypeError( 'invalid argument. First argument must be an array. Value: `' + tokens + '`.' );\n\t}\n\tout = '';\n\tpos = 1;\n\tfor ( i = 0; i < tokens.length; i++ ) {\n\t\ttoken = tokens[ i ];\n\t\tif ( isString( token ) ) {\n\t\t\tout += token;\n\t\t} else {\n\t\t\thasPeriod = token.precision !== void 0;\n\t\t\ttoken = initialize( token );\n\t\t\tif ( !token.specifier ) {\n\t\t\t\tthrow new TypeError( 'invalid argument. Token is missing `specifier` property. Index: `'+ i +'`. Value: `' + token + '`.' );\n\t\t\t}\n\t\t\tif ( token.mapping ) {\n\t\t\t\tpos = token.mapping;\n\t\t\t}\n\t\t\tflags = token.flags;\n\t\t\tfor ( j = 0; j < flags.length; j++ ) {\n\t\t\t\tflag = flags.charAt( j );\n\t\t\t\tswitch ( flag ) {\n\t\t\t\tcase ' ':\n\t\t\t\t\ttoken.sign = ' ';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\ttoken.sign = '+';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\ttoken.padRight = true;\n\t\t\t\t\ttoken.padZeros = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\t\ttoken.padZeros = flags.indexOf( '-' ) < 0; // NOTE: We use built-in `Array.prototype.indexOf` here instead of `@stdlib/assert/contains` in order to avoid circular dependencies.\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\ttoken.alternate = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'invalid flag: ' + flag );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( token.width === '*' ) {\n\t\t\t\ttoken.width = parseInt( arguments[ pos ], 10 );\n\t\t\t\tpos += 1;\n\t\t\t\tif ( isnan( token.width ) ) {\n\t\t\t\t\tthrow new TypeError( 'the argument for * width at position ' + pos + ' is not a number. Value: `' + token.width + '`.' );\n\t\t\t\t}\n\t\t\t\tif ( token.width < 0 ) {\n\t\t\t\t\ttoken.padRight = true;\n\t\t\t\t\ttoken.width = -token.width;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( hasPeriod ) {\n\t\t\t\tif ( token.precision === '*' ) {\n\t\t\t\t\ttoken.precision = parseInt( arguments[ pos ], 10 );\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tif ( isnan( token.precision ) ) {\n\t\t\t\t\t\tthrow new TypeError( 'the argument for * precision at position ' + pos + ' is not a number. Value: `' + token.precision + '`.' );\n\t\t\t\t\t}\n\t\t\t\t\tif ( token.precision < 0 ) {\n\t\t\t\t\t\ttoken.precision = 1;\n\t\t\t\t\t\thasPeriod = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoken.arg = arguments[ pos ];\n\t\t\tswitch ( token.specifier ) {\n\t\t\tcase 'b':\n\t\t\tcase 'o':\n\t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\tcase 'd':\n\t\t\tcase 'i':\n\t\t\tcase 'u':\n\t\t\t\t// Case: %b (binary), %o (octal), %x, %X (hexadecimal), %d, %i (decimal), %u (unsigned decimal)\n\t\t\t\tif ( hasPeriod ) {\n\t\t\t\t\ttoken.padZeros = false;\n\t\t\t\t}\n\t\t\t\ttoken.arg = formatInteger( token );\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\t// Case: %s (string)\n\t\t\t\ttoken.maxWidth = ( hasPeriod ) ? token.precision : -1;\n\t\t\t\ttoken.arg = String( token.arg );\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\t// Case: %c (character)\n\t\t\t\tif ( !isnan( token.arg ) ) {\n\t\t\t\t\tnum = parseInt( token.arg, 10 );\n\t\t\t\t\tif ( num < 0 || num > 127 ) {\n\t\t\t\t\t\tthrow new Error( 'invalid character code. Value: ' + token.arg );\n\t\t\t\t\t}\n\t\t\t\t\ttoken.arg = ( isnan( num ) ) ? String( token.arg ) : fromCharCode( num ); // eslint-disable-line max-len\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\tcase 'E':\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\tcase 'g':\n\t\t\tcase 'G':\n\t\t\t\t// Case: %e, %E (scientific notation), %f, %F (decimal floating point), %g, %G (uses the shorter of %e/E or %f/F)\n\t\t\t\tif ( !hasPeriod ) {\n\t\t\t\t\ttoken.precision = 6;\n\t\t\t\t}\n\t\t\t\ttoken.arg = formatDouble( token );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'invalid specifier: ' + token.specifier );\n\t\t\t}\n\t\t\t// Fit argument into field width...\n\t\t\tif ( token.maxWidth >= 0 && token.arg.length > token.maxWidth ) {\n\t\t\t\ttoken.arg = token.arg.substring( 0, token.maxWidth );\n\t\t\t}\n\t\t\tif ( token.padZeros ) {\n\t\t\t\ttoken.arg = zeroPad( token.arg, token.width || token.precision, token.padRight ); // eslint-disable-line max-len\n\t\t\t} else if ( token.width ) {\n\t\t\t\ttoken.arg = spacePad( token.arg, token.width, token.padRight );\n\t\t\t}\n\t\t\tout += token.arg || '';\n\t\t\tpos += 1;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = formatInterpolate;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}