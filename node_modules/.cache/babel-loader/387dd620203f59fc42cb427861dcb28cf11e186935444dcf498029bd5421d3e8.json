{"ast":null,"code":"/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/s_pow.c}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n* ```\n*/\n\n'use strict';\n\n// MODULES //\nvar isnan = require('@stdlib/math-base-assert-is-nan');\nvar isOdd = require('@stdlib/math-base-assert-is-odd');\nvar isInfinite = require('@stdlib/math-base-assert-is-infinite');\nvar isInteger = require('@stdlib/math-base-assert-is-integer');\nvar sqrt = require('@stdlib/math-base-special-sqrt');\nvar abs = require('@stdlib/math-base-special-abs');\nvar toWords = require('@stdlib/number-float64-base-to-words');\nvar setLowWord = require('@stdlib/number-float64-base-set-low-word');\nvar uint32ToInt32 = require('@stdlib/number-uint32-base-to-int32');\nvar NINF = require('@stdlib/constants-float64-ninf');\nvar PINF = require('@stdlib/constants-float64-pinf');\nvar ABS_MASK = require('@stdlib/constants-float64-high-word-abs-mask');\nvar xIsZero = require('./x_is_zero.js');\nvar yIsHuge = require('./y_is_huge.js');\nvar yIsInfinite = require('./y_is_infinite.js');\nvar log2ax = require('./log2ax.js');\nvar logx = require('./logx.js');\nvar pow2 = require('./pow2.js');\n\n// VARIABLES //\n\n// 0x3fefffff = 1072693247 => 0 01111111110 11111111111111111111 => biased exponent: 1022 = -1+1023 => 2^-1\nvar HIGH_MAX_NEAR_UNITY = 0x3fefffff | 0; // asm type annotation\n\n// 0x41e00000 = 1105199104 => 0 10000011110 00000000000000000000 => biased exponent: 1054 = 31+1023 => 2^31\nvar HIGH_BIASED_EXP_31 = 0x41e00000 | 0; // asm type annotation\n\n// 0x43f00000 = 1139802112 => 0 10000111111 00000000000000000000 => biased exponent: 1087 = 64+1023 => 2^64\nvar HIGH_BIASED_EXP_64 = 0x43f00000 | 0; // asm type annotation\n\n// 0x40900000 = 1083179008 => 0 10000001001 00000000000000000000 => biased exponent: 1033 = 10+1023 => 2^10 = 1024\nvar HIGH_BIASED_EXP_10 = 0x40900000 | 0; // asm type annotation\n\n// 0x3ff00000 = 1072693248 => 0 01111111111 00000000000000000000 => biased exponent: 1023 = 0+1023 => 2^0 = 1\nvar HIGH_BIASED_EXP_0 = 0x3ff00000 | 0; // asm type annotation\n\n// 0x4090cc00 = 1083231232 => 0 10000001001 00001100110000000000\nvar HIGH_1075 = 0x4090cc00 | 0; // asm type annotation\n\n// 0xc090cc00 = 3230714880 => 1 10000001001 00001100110000000000\nvar HIGH_NEG_1075 = 0xc090cc00 >>> 0; // asm type annotation\n\nvar HIGH_NUM_NONSIGN_BITS = 31 | 0; // asm type annotation\n\nvar HUGE = 1.0e300;\nvar TINY = 1.0e-300;\n\n// -(1024-log2(ovfl+.5ulp))\nvar OVT = 8.0085662595372944372e-17;\n\n// High/low words workspace:\nvar WORDS = [0 | 0, 0 | 0];\n\n// Log workspace:\nvar LOG_WORKSPACE = [0.0, 0.0];\n\n// MAIN //\n\n/**\n* Evaluates the exponential function.\n*\n* ## Method\n*\n* 1.  Let \\\\(x = 2^n (1+f)\\\\).\n*\n* 2.  Compute \\\\(\\operatorname{log2}(x)\\\\) as\n*\n*     ```tex\n*     \\operatorname{log2}(x) = w_1 + w_2\n*     ```\n*\n*     where \\\\(w_1\\\\) has \\\\(53 - 24 = 29\\\\) bit trailing zeros.\n*\n* 3.  Compute\n*\n*     ```tex\n*     y \\cdot \\operatorname{log2}(x) = n + y^\\prime\n*     ```\n*\n*     by simulating multi-precision arithmetic, where \\\\(|y^\\prime| \\leq 0.5\\\\).\n*\n* 4.  Return\n*\n*     ```tex\n*     x^y = 2^n e^{y^\\prime \\cdot \\mathrm{log2}}\n*     ```\n*\n* ## Special Cases\n*\n* ```tex\n* \\begin{align*}\n* x^{\\mathrm{NaN}} &= \\mathrm{NaN} & \\\\\n* (\\mathrm{NaN})^y &= \\mathrm{NaN} & \\\\\n* 1^y &= 1 & \\\\\n* x^0 &= 1 & \\\\\n* x^1 &= x & \\\\\n* (\\pm 0)^\\infty &= +0 & \\\\\n* (\\pm 0)^{-\\infty} &= +\\infty & \\\\\n* (+0)^y &= +0 & \\mathrm{if}\\ y > 0 \\\\\n* (+0)^y &= +\\infty & \\mathrm{if}\\ y < 0 \\\\\n* (-0)^y &= -\\infty & \\mathrm{if}\\ y\\ \\mathrm{is\\ an\\ odd\\ integer\\ and}\\ y < 0 \\\\\n* (-0)^y &= +\\infty & \\mathrm{if}\\ y\\ \\mathrm{is\\ not\\ an\\ odd\\ integer\\ and}\\ y < 0 \\\\\n* (-0)^y &= -0 & \\mathrm{if}\\ y\\ \\mathrm{is\\ an\\ odd\\ integer\\ and}\\ y > 0 \\\\\n* (-0)^y &= +0 & \\mathrm{if}\\ y\\ \\mathrm{is\\ not\\ an\\ odd\\ integer\\ and}\\ y > 0 \\\\\n* (-1)^{\\pm\\infty} &= \\mathrm{NaN} & \\\\\n* x^{\\infty} &= +\\infty & |x| > 1 \\\\\n* x^{\\infty} &= +0 & |x| < 1 \\\\\n* x^{-\\infty} &= +0 & |x| > 1 \\\\\n* x^{-\\infty} &= +\\infty & |x| < 1 \\\\\n* (-\\infty)^y &= (-0)^y & \\\\\n* \\infty^y &= +0 & y < 0 \\\\\n* \\infty^y &= +\\infty & y > 0 \\\\\n* x^y &= \\mathrm{NaN} & \\mathrm{if}\\ y\\ \\mathrm{is\\ not\\ a\\ finite\\ integer\\ and}\\ x < 0\n* \\end{align*}\n* ```\n*\n* ## Notes\n*\n* -   \\\\(\\operatorname{pow}(x,y)\\\\) returns \\\\(x^y\\\\) nearly rounded. In particular, \\\\(\\operatorname{pow}(<\\mathrm{integer}>,<\\mathrm{integer}>)\\\\) **always** returns the correct integer, provided the value is representable.\n* -   The hexadecimal values shown in the source code are the intended values for used constants. Decimal values may be used, provided the compiler will accurately convert decimal to binary in order to produce the hexadecimal values.\n*\n* @param {number} x - base\n* @param {number} y - exponent\n* @returns {number} function value\n*\n* @example\n* var v = pow( 2.0, 3.0 );\n* // returns 8.0\n*\n* @example\n* var v = pow( 4.0, 0.5 );\n* // returns 2.0\n*\n* @example\n* var v = pow( 100.0, 0.0 );\n* // returns 1.0\n*\n* @example\n* var v = pow( 3.141592653589793, 5.0 );\n* // returns ~306.0197\n*\n* @example\n* var v = pow( 3.141592653589793, -0.2 );\n* // returns ~0.7954\n*\n* @example\n* var v = pow( NaN, 3.0 );\n* // returns NaN\n*\n* @example\n* var v = pow( 5.0, NaN );\n* // returns NaN\n*\n* @example\n* var v = pow( NaN, NaN );\n* // returns NaN\n*/\nfunction pow(x, y) {\n  var ahx; // absolute value high word `x`\n  var ahy; // absolute value high word `y`\n  var ax; // absolute value `x`\n  var hx; // high word `x`\n  var lx; // low word `x`\n  var hy; // high word `y`\n  var ly; // low word `y`\n  var sx; // sign `x`\n  var sy; // sign `y`\n  var y1;\n  var hp;\n  var lp;\n  var t;\n  var z; // y prime\n  var j;\n  var i;\n  if (isnan(x) || isnan(y)) {\n    return NaN;\n  }\n  // Split `y` into high and low words:\n  toWords.assign(y, WORDS, 1, 0);\n  hy = WORDS[0];\n  ly = WORDS[1];\n\n  // Special cases `y`...\n  if (ly === 0) {\n    if (y === 0.0) {\n      return 1.0;\n    }\n    if (y === 1.0) {\n      return x;\n    }\n    if (y === -1.0) {\n      return 1.0 / x;\n    }\n    if (y === 0.5) {\n      return sqrt(x);\n    }\n    if (y === -0.5) {\n      return 1.0 / sqrt(x);\n    }\n    if (y === 2.0) {\n      return x * x;\n    }\n    if (y === 3.0) {\n      return x * x * x;\n    }\n    if (y === 4.0) {\n      x *= x;\n      return x * x;\n    }\n    if (isInfinite(y)) {\n      return yIsInfinite(x, y);\n    }\n  }\n  // Split `x` into high and low words:\n  toWords.assign(x, WORDS, 1, 0);\n  hx = WORDS[0];\n  lx = WORDS[1];\n\n  // Special cases `x`...\n  if (lx === 0) {\n    if (hx === 0) {\n      return xIsZero(x, y);\n    }\n    if (x === 1.0) {\n      return 1.0;\n    }\n    if (x === -1.0 && isOdd(y)) {\n      return -1.0;\n    }\n    if (isInfinite(x)) {\n      if (x === NINF) {\n        // `pow( 1/x, -y )`\n        return pow(-0.0, -y);\n      }\n      if (y < 0.0) {\n        return 0.0;\n      }\n      return PINF;\n    }\n  }\n  if (x < 0.0 && isInteger(y) === false) {\n    // Signal NaN...\n    return (x - x) / (x - x);\n  }\n  ax = abs(x);\n\n  // Remove the sign bits (i.e., get absolute values):\n  ahx = hx & ABS_MASK | 0; // asm type annotation\n  ahy = hy & ABS_MASK | 0; // asm type annotation\n\n  // Extract the sign bits:\n  sx = hx >>> HIGH_NUM_NONSIGN_BITS | 0; // asm type annotation\n  sy = hy >>> HIGH_NUM_NONSIGN_BITS | 0; // asm type annotation\n\n  // Determine the sign of the result...\n  if (sx && isOdd(y)) {\n    sx = -1.0;\n  } else {\n    sx = 1.0;\n  }\n  // Case 1: `|y|` is huge...\n\n  // |y| > 2^31\n  if (ahy > HIGH_BIASED_EXP_31) {\n    // `|y| > 2^64`, then must over- or underflow...\n    if (ahy > HIGH_BIASED_EXP_64) {\n      return yIsHuge(x, y);\n    }\n    // Over- or underflow if `x` is not close to unity...\n\n    if (ahx < HIGH_MAX_NEAR_UNITY) {\n      // y < 0\n      if (sy === 1) {\n        // Signal overflow...\n        return sx * HUGE * HUGE;\n      }\n      // Signal underflow...\n      return sx * TINY * TINY;\n    }\n    if (ahx > HIGH_BIASED_EXP_0) {\n      // y > 0\n      if (sy === 0) {\n        // Signal overflow...\n        return sx * HUGE * HUGE;\n      }\n      // Signal underflow...\n      return sx * TINY * TINY;\n    }\n    // At this point, `|1-x|` is tiny (`<= 2^-20`). Suffice to compute `log(x)` by `x - x^2/2 + x^3/3 - x^4/4`.\n    t = logx(LOG_WORKSPACE, ax);\n  }\n  // Case 2: `|y|` is not huge...\n  else {\n    t = log2ax(LOG_WORKSPACE, ax, ahx);\n  }\n  // Split `y` into `y1 + y2` and compute `(y1+y2) * (t1+t2)`...\n  y1 = setLowWord(y, 0);\n  lp = (y - y1) * t[0] + y * t[1];\n  hp = y1 * t[0];\n  z = lp + hp;\n\n  // Note: *can* be more performant to use `getHighWord` and `getLowWord` directly, but using `toWords` looks cleaner.\n  toWords.assign(z, WORDS, 1, 0);\n  j = uint32ToInt32(WORDS[0]);\n  i = uint32ToInt32(WORDS[1]);\n\n  // z >= 1024\n  if (j >= HIGH_BIASED_EXP_10) {\n    // z > 1024\n    if ((j - HIGH_BIASED_EXP_10 | i) !== 0) {\n      // Signal overflow...\n      return sx * HUGE * HUGE;\n    }\n    if (lp + OVT > z - hp) {\n      // Signal overflow...\n      return sx * HUGE * HUGE;\n    }\n  }\n  // z <= -1075\n  else if ((j & ABS_MASK) >= HIGH_1075) {\n    // z < -1075\n    if ((j - HIGH_NEG_1075 | i) !== 0) {\n      // Signal underflow...\n      return sx * TINY * TINY;\n    }\n    if (lp <= z - hp) {\n      // Signal underflow...\n      return sx * TINY * TINY;\n    }\n  }\n  // Compute `2^(hp+lp)`...\n  z = pow2(j, hp, lp);\n  return sx * z;\n}\n\n// EXPORTS //\n\nmodule.exports = pow;","map":{"version":3,"names":["isnan","require","isOdd","isInfinite","isInteger","sqrt","abs","toWords","setLowWord","uint32ToInt32","NINF","PINF","ABS_MASK","xIsZero","yIsHuge","yIsInfinite","log2ax","logx","pow2","HIGH_MAX_NEAR_UNITY","HIGH_BIASED_EXP_31","HIGH_BIASED_EXP_64","HIGH_BIASED_EXP_10","HIGH_BIASED_EXP_0","HIGH_1075","HIGH_NEG_1075","HIGH_NUM_NONSIGN_BITS","HUGE","TINY","OVT","WORDS","LOG_WORKSPACE","pow","x","y","ahx","ahy","ax","hx","lx","hy","ly","sx","sy","y1","hp","lp","t","z","j","i","NaN","assign","module","exports"],"sources":["D:/INTERNSHIP-PROJECT-WORK/stat/node_modules/@stdlib/math-base-special-pow/lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/s_pow.c}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isnan = require( '@stdlib/math-base-assert-is-nan' );\nvar isOdd = require( '@stdlib/math-base-assert-is-odd' );\nvar isInfinite = require( '@stdlib/math-base-assert-is-infinite' );\nvar isInteger = require( '@stdlib/math-base-assert-is-integer' );\nvar sqrt = require( '@stdlib/math-base-special-sqrt' );\nvar abs = require( '@stdlib/math-base-special-abs' );\nvar toWords = require( '@stdlib/number-float64-base-to-words' );\nvar setLowWord = require( '@stdlib/number-float64-base-set-low-word' );\nvar uint32ToInt32 = require( '@stdlib/number-uint32-base-to-int32' );\nvar NINF = require( '@stdlib/constants-float64-ninf' );\nvar PINF = require( '@stdlib/constants-float64-pinf' );\nvar ABS_MASK = require( '@stdlib/constants-float64-high-word-abs-mask' );\nvar xIsZero = require( './x_is_zero.js' );\nvar yIsHuge = require( './y_is_huge.js' );\nvar yIsInfinite = require( './y_is_infinite.js' );\nvar log2ax = require( './log2ax.js' );\nvar logx = require( './logx.js' );\nvar pow2 = require( './pow2.js' );\n\n\n// VARIABLES //\n\n// 0x3fefffff = 1072693247 => 0 01111111110 11111111111111111111 => biased exponent: 1022 = -1+1023 => 2^-1\nvar HIGH_MAX_NEAR_UNITY = 0x3fefffff|0; // asm type annotation\n\n// 0x41e00000 = 1105199104 => 0 10000011110 00000000000000000000 => biased exponent: 1054 = 31+1023 => 2^31\nvar HIGH_BIASED_EXP_31 = 0x41e00000|0; // asm type annotation\n\n// 0x43f00000 = 1139802112 => 0 10000111111 00000000000000000000 => biased exponent: 1087 = 64+1023 => 2^64\nvar HIGH_BIASED_EXP_64 = 0x43f00000|0; // asm type annotation\n\n// 0x40900000 = 1083179008 => 0 10000001001 00000000000000000000 => biased exponent: 1033 = 10+1023 => 2^10 = 1024\nvar HIGH_BIASED_EXP_10 = 0x40900000|0; // asm type annotation\n\n// 0x3ff00000 = 1072693248 => 0 01111111111 00000000000000000000 => biased exponent: 1023 = 0+1023 => 2^0 = 1\nvar HIGH_BIASED_EXP_0 = 0x3ff00000|0; // asm type annotation\n\n// 0x4090cc00 = 1083231232 => 0 10000001001 00001100110000000000\nvar HIGH_1075 = 0x4090cc00|0; // asm type annotation\n\n// 0xc090cc00 = 3230714880 => 1 10000001001 00001100110000000000\nvar HIGH_NEG_1075 = 0xc090cc00>>>0; // asm type annotation\n\nvar HIGH_NUM_NONSIGN_BITS = 31|0; // asm type annotation\n\nvar HUGE = 1.0e300;\nvar TINY = 1.0e-300;\n\n// -(1024-log2(ovfl+.5ulp))\nvar OVT = 8.0085662595372944372e-17;\n\n// High/low words workspace:\nvar WORDS = [ 0|0, 0|0 ];\n\n// Log workspace:\nvar LOG_WORKSPACE = [ 0.0, 0.0 ];\n\n\n// MAIN //\n\n/**\n* Evaluates the exponential function.\n*\n* ## Method\n*\n* 1.  Let \\\\(x = 2^n (1+f)\\\\).\n*\n* 2.  Compute \\\\(\\operatorname{log2}(x)\\\\) as\n*\n*     ```tex\n*     \\operatorname{log2}(x) = w_1 + w_2\n*     ```\n*\n*     where \\\\(w_1\\\\) has \\\\(53 - 24 = 29\\\\) bit trailing zeros.\n*\n* 3.  Compute\n*\n*     ```tex\n*     y \\cdot \\operatorname{log2}(x) = n + y^\\prime\n*     ```\n*\n*     by simulating multi-precision arithmetic, where \\\\(|y^\\prime| \\leq 0.5\\\\).\n*\n* 4.  Return\n*\n*     ```tex\n*     x^y = 2^n e^{y^\\prime \\cdot \\mathrm{log2}}\n*     ```\n*\n* ## Special Cases\n*\n* ```tex\n* \\begin{align*}\n* x^{\\mathrm{NaN}} &= \\mathrm{NaN} & \\\\\n* (\\mathrm{NaN})^y &= \\mathrm{NaN} & \\\\\n* 1^y &= 1 & \\\\\n* x^0 &= 1 & \\\\\n* x^1 &= x & \\\\\n* (\\pm 0)^\\infty &= +0 & \\\\\n* (\\pm 0)^{-\\infty} &= +\\infty & \\\\\n* (+0)^y &= +0 & \\mathrm{if}\\ y > 0 \\\\\n* (+0)^y &= +\\infty & \\mathrm{if}\\ y < 0 \\\\\n* (-0)^y &= -\\infty & \\mathrm{if}\\ y\\ \\mathrm{is\\ an\\ odd\\ integer\\ and}\\ y < 0 \\\\\n* (-0)^y &= +\\infty & \\mathrm{if}\\ y\\ \\mathrm{is\\ not\\ an\\ odd\\ integer\\ and}\\ y < 0 \\\\\n* (-0)^y &= -0 & \\mathrm{if}\\ y\\ \\mathrm{is\\ an\\ odd\\ integer\\ and}\\ y > 0 \\\\\n* (-0)^y &= +0 & \\mathrm{if}\\ y\\ \\mathrm{is\\ not\\ an\\ odd\\ integer\\ and}\\ y > 0 \\\\\n* (-1)^{\\pm\\infty} &= \\mathrm{NaN} & \\\\\n* x^{\\infty} &= +\\infty & |x| > 1 \\\\\n* x^{\\infty} &= +0 & |x| < 1 \\\\\n* x^{-\\infty} &= +0 & |x| > 1 \\\\\n* x^{-\\infty} &= +\\infty & |x| < 1 \\\\\n* (-\\infty)^y &= (-0)^y & \\\\\n* \\infty^y &= +0 & y < 0 \\\\\n* \\infty^y &= +\\infty & y > 0 \\\\\n* x^y &= \\mathrm{NaN} & \\mathrm{if}\\ y\\ \\mathrm{is\\ not\\ a\\ finite\\ integer\\ and}\\ x < 0\n* \\end{align*}\n* ```\n*\n* ## Notes\n*\n* -   \\\\(\\operatorname{pow}(x,y)\\\\) returns \\\\(x^y\\\\) nearly rounded. In particular, \\\\(\\operatorname{pow}(<\\mathrm{integer}>,<\\mathrm{integer}>)\\\\) **always** returns the correct integer, provided the value is representable.\n* -   The hexadecimal values shown in the source code are the intended values for used constants. Decimal values may be used, provided the compiler will accurately convert decimal to binary in order to produce the hexadecimal values.\n*\n* @param {number} x - base\n* @param {number} y - exponent\n* @returns {number} function value\n*\n* @example\n* var v = pow( 2.0, 3.0 );\n* // returns 8.0\n*\n* @example\n* var v = pow( 4.0, 0.5 );\n* // returns 2.0\n*\n* @example\n* var v = pow( 100.0, 0.0 );\n* // returns 1.0\n*\n* @example\n* var v = pow( 3.141592653589793, 5.0 );\n* // returns ~306.0197\n*\n* @example\n* var v = pow( 3.141592653589793, -0.2 );\n* // returns ~0.7954\n*\n* @example\n* var v = pow( NaN, 3.0 );\n* // returns NaN\n*\n* @example\n* var v = pow( 5.0, NaN );\n* // returns NaN\n*\n* @example\n* var v = pow( NaN, NaN );\n* // returns NaN\n*/\nfunction pow( x, y ) {\n\tvar ahx; // absolute value high word `x`\n\tvar ahy; // absolute value high word `y`\n\tvar ax;  // absolute value `x`\n\tvar hx;  // high word `x`\n\tvar lx;  // low word `x`\n\tvar hy;  // high word `y`\n\tvar ly;  // low word `y`\n\tvar sx;  // sign `x`\n\tvar sy;  // sign `y`\n\tvar y1;\n\tvar hp;\n\tvar lp;\n\tvar t;\n\tvar z;   // y prime\n\tvar j;\n\tvar i;\n\tif ( isnan( x ) || isnan( y ) ) {\n\t\treturn NaN;\n\t}\n\t// Split `y` into high and low words:\n\ttoWords.assign( y, WORDS, 1, 0 );\n\thy = WORDS[ 0 ];\n\tly = WORDS[ 1 ];\n\n\t// Special cases `y`...\n\tif ( ly === 0 ) {\n\t\tif ( y === 0.0 ) {\n\t\t\treturn 1.0;\n\t\t}\n\t\tif ( y === 1.0 ) {\n\t\t\treturn x;\n\t\t}\n\t\tif ( y === -1.0 ) {\n\t\t\treturn 1.0 / x;\n\t\t}\n\t\tif ( y === 0.5 ) {\n\t\t\treturn sqrt( x );\n\t\t}\n\t\tif ( y === -0.5 ) {\n\t\t\treturn 1.0 / sqrt( x );\n\t\t}\n\t\tif ( y === 2.0 ) {\n\t\t\treturn x * x;\n\t\t}\n\t\tif ( y === 3.0 ) {\n\t\t\treturn x * x * x;\n\t\t}\n\t\tif ( y === 4.0 ) {\n\t\t\tx *= x;\n\t\t\treturn x * x;\n\t\t}\n\t\tif ( isInfinite( y ) ) {\n\t\t\treturn yIsInfinite( x, y );\n\t\t}\n\t}\n\t// Split `x` into high and low words:\n\ttoWords.assign( x, WORDS, 1, 0 );\n\thx = WORDS[ 0 ];\n\tlx = WORDS[ 1 ];\n\n\t// Special cases `x`...\n\tif ( lx === 0 ) {\n\t\tif ( hx === 0 ) {\n\t\t\treturn xIsZero( x, y );\n\t\t}\n\t\tif ( x === 1.0 ) {\n\t\t\treturn 1.0;\n\t\t}\n\t\tif (\n\t\t\tx === -1.0 &&\n\t\t\tisOdd( y )\n\t\t) {\n\t\t\treturn -1.0;\n\t\t}\n\t\tif ( isInfinite( x ) ) {\n\t\t\tif ( x === NINF ) {\n\t\t\t\t// `pow( 1/x, -y )`\n\t\t\t\treturn pow( -0.0, -y );\n\t\t\t}\n\t\t\tif ( y < 0.0 ) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn PINF;\n\t\t}\n\t}\n\tif (\n\t\tx < 0.0 &&\n\t\tisInteger( y ) === false\n\t) {\n\t\t// Signal NaN...\n\t\treturn (x-x)/(x-x);\n\t}\n\tax = abs( x );\n\n\t// Remove the sign bits (i.e., get absolute values):\n\tahx = (hx & ABS_MASK)|0; // asm type annotation\n\tahy = (hy & ABS_MASK)|0; // asm type annotation\n\n\t// Extract the sign bits:\n\tsx = (hx >>> HIGH_NUM_NONSIGN_BITS)|0; // asm type annotation\n\tsy = (hy >>> HIGH_NUM_NONSIGN_BITS)|0; // asm type annotation\n\n\t// Determine the sign of the result...\n\tif ( sx && isOdd( y ) ) {\n\t\tsx = -1.0;\n\t} else {\n\t\tsx = 1.0;\n\t}\n\t// Case 1: `|y|` is huge...\n\n\t// |y| > 2^31\n\tif ( ahy > HIGH_BIASED_EXP_31 ) {\n\t\t// `|y| > 2^64`, then must over- or underflow...\n\t\tif ( ahy > HIGH_BIASED_EXP_64 ) {\n\t\t\treturn yIsHuge( x, y );\n\t\t}\n\t\t// Over- or underflow if `x` is not close to unity...\n\n\t\tif ( ahx < HIGH_MAX_NEAR_UNITY ) {\n\t\t\t// y < 0\n\t\t\tif ( sy === 1 ) {\n\t\t\t\t// Signal overflow...\n\t\t\t\treturn sx * HUGE * HUGE;\n\t\t\t}\n\t\t\t// Signal underflow...\n\t\t\treturn sx * TINY * TINY;\n\t\t}\n\t\tif ( ahx > HIGH_BIASED_EXP_0 ) {\n\t\t\t// y > 0\n\t\t\tif ( sy === 0 ) {\n\t\t\t\t// Signal overflow...\n\t\t\t\treturn sx * HUGE * HUGE;\n\t\t\t}\n\t\t\t// Signal underflow...\n\t\t\treturn sx * TINY * TINY;\n\t\t}\n\t\t// At this point, `|1-x|` is tiny (`<= 2^-20`). Suffice to compute `log(x)` by `x - x^2/2 + x^3/3 - x^4/4`.\n\t\tt = logx( LOG_WORKSPACE, ax );\n\t}\n\t// Case 2: `|y|` is not huge...\n\telse {\n\t\tt = log2ax( LOG_WORKSPACE, ax, ahx );\n\t}\n\t// Split `y` into `y1 + y2` and compute `(y1+y2) * (t1+t2)`...\n\ty1 = setLowWord( y, 0 );\n\tlp = ( (y-y1)*t[0] ) + ( y*t[1] );\n\thp = y1 * t[0];\n\tz = lp + hp;\n\n\t// Note: *can* be more performant to use `getHighWord` and `getLowWord` directly, but using `toWords` looks cleaner.\n\ttoWords.assign( z, WORDS, 1, 0 );\n\tj = uint32ToInt32( WORDS[0] );\n\ti = uint32ToInt32( WORDS[1] );\n\n\t// z >= 1024\n\tif ( j >= HIGH_BIASED_EXP_10 ) {\n\t\t// z > 1024\n\t\tif ( ((j-HIGH_BIASED_EXP_10)|i) !== 0 ) {\n\t\t\t// Signal overflow...\n\t\t\treturn sx * HUGE * HUGE;\n\t\t}\n\t\tif ( (lp+OVT) > (z-hp) ) {\n\t\t\t// Signal overflow...\n\t\t\treturn sx * HUGE * HUGE;\n\t\t}\n\t}\n\t// z <= -1075\n\telse if ( (j&ABS_MASK) >= HIGH_1075 ) {\n\t\t// z < -1075\n\t\tif ( ((j-HIGH_NEG_1075)|i) !== 0 ) {\n\t\t\t// Signal underflow...\n\t\t\treturn sx * TINY * TINY;\n\t\t}\n\t\tif ( lp <= (z-hp) ) {\n\t\t\t// Signal underflow...\n\t\t\treturn sx * TINY * TINY;\n\t\t}\n\t}\n\t// Compute `2^(hp+lp)`...\n\tz = pow2( j, hp, lp );\n\n\treturn sx * z;\n}\n\n\n// EXPORTS //\n\nmodule.exports = pow;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAE,iCAAkC,CAAC;AACxD,IAAIC,KAAK,GAAGD,OAAO,CAAE,iCAAkC,CAAC;AACxD,IAAIE,UAAU,GAAGF,OAAO,CAAE,sCAAuC,CAAC;AAClE,IAAIG,SAAS,GAAGH,OAAO,CAAE,qCAAsC,CAAC;AAChE,IAAII,IAAI,GAAGJ,OAAO,CAAE,gCAAiC,CAAC;AACtD,IAAIK,GAAG,GAAGL,OAAO,CAAE,+BAAgC,CAAC;AACpD,IAAIM,OAAO,GAAGN,OAAO,CAAE,sCAAuC,CAAC;AAC/D,IAAIO,UAAU,GAAGP,OAAO,CAAE,0CAA2C,CAAC;AACtE,IAAIQ,aAAa,GAAGR,OAAO,CAAE,qCAAsC,CAAC;AACpE,IAAIS,IAAI,GAAGT,OAAO,CAAE,gCAAiC,CAAC;AACtD,IAAIU,IAAI,GAAGV,OAAO,CAAE,gCAAiC,CAAC;AACtD,IAAIW,QAAQ,GAAGX,OAAO,CAAE,8CAA+C,CAAC;AACxE,IAAIY,OAAO,GAAGZ,OAAO,CAAE,gBAAiB,CAAC;AACzC,IAAIa,OAAO,GAAGb,OAAO,CAAE,gBAAiB,CAAC;AACzC,IAAIc,WAAW,GAAGd,OAAO,CAAE,oBAAqB,CAAC;AACjD,IAAIe,MAAM,GAAGf,OAAO,CAAE,aAAc,CAAC;AACrC,IAAIgB,IAAI,GAAGhB,OAAO,CAAE,WAAY,CAAC;AACjC,IAAIiB,IAAI,GAAGjB,OAAO,CAAE,WAAY,CAAC;;AAGjC;;AAEA;AACA,IAAIkB,mBAAmB,GAAG,UAAU,GAAC,CAAC,CAAC,CAAC;;AAExC;AACA,IAAIC,kBAAkB,GAAG,UAAU,GAAC,CAAC,CAAC,CAAC;;AAEvC;AACA,IAAIC,kBAAkB,GAAG,UAAU,GAAC,CAAC,CAAC,CAAC;;AAEvC;AACA,IAAIC,kBAAkB,GAAG,UAAU,GAAC,CAAC,CAAC,CAAC;;AAEvC;AACA,IAAIC,iBAAiB,GAAG,UAAU,GAAC,CAAC,CAAC,CAAC;;AAEtC;AACA,IAAIC,SAAS,GAAG,UAAU,GAAC,CAAC,CAAC,CAAC;;AAE9B;AACA,IAAIC,aAAa,GAAG,UAAU,KAAG,CAAC,CAAC,CAAC;;AAEpC,IAAIC,qBAAqB,GAAG,EAAE,GAAC,CAAC,CAAC,CAAC;;AAElC,IAAIC,IAAI,GAAG,OAAO;AAClB,IAAIC,IAAI,GAAG,QAAQ;;AAEnB;AACA,IAAIC,GAAG,GAAG,yBAAyB;;AAEnC;AACA,IAAIC,KAAK,GAAG,CAAE,CAAC,GAAC,CAAC,EAAE,CAAC,GAAC,CAAC,CAAE;;AAExB;AACA,IAAIC,aAAa,GAAG,CAAE,GAAG,EAAE,GAAG,CAAE;;AAGhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,GAAGA,CAAEC,CAAC,EAAEC,CAAC,EAAG;EACpB,IAAIC,GAAG,CAAC,CAAC;EACT,IAAIC,GAAG,CAAC,CAAC;EACT,IAAIC,EAAE,CAAC,CAAE;EACT,IAAIC,EAAE,CAAC,CAAE;EACT,IAAIC,EAAE,CAAC,CAAE;EACT,IAAIC,EAAE,CAAC,CAAE;EACT,IAAIC,EAAE,CAAC,CAAE;EACT,IAAIC,EAAE,CAAC,CAAE;EACT,IAAIC,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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}